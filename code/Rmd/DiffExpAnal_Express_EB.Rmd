---
title: "Differential expression analysis for eXpress aligned data (EB's only)"
author: "Thanneer Perumal"
date: "`r date()`"
output: html_document
---

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file is
# Load required libraries
library('synapseClient')
library('limma')
library('edgeR')
library('RColorBrewer')
library('ctv')
library('ggplot2')
library('psych')
library('reshape2')
library('gplots')
library('vcd')
library('psych')
library('erer')
library('fpc')
library('data.table')
library('dplyr')

## Requires ggdendro
devtools::source_url("https://raw.githubusercontent.com/chr1swallace/random-functions/master/R/ggplot-heatmap.R")

# source('/mnt/Github/Knit2Synapse/knit2synapse.R')
# knit2synapse(file = "./", owner = '', wikiName = "",overwrite=T)

synapseLogin()

# source utility files from ../R/lib folder
file.sources = list.files('../R/lib',pattern="*.R")
file.sources = sapply(file.sources,function(x){return(paste('../R/lib',x,sep='/'))})
tmp = sapply(file.sources,source,.GlobalEnv)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE)
```

### Download data

```{r setup, include=FALSE}
# Input Parameters
COUNT_ID = 'syn3446250'
METADATA_ID = 'syn3156503'
OUTLIERS_ID = 'NULL'

SYNAPSE_STORE = F
parentId = 'syn3276099'

# Specify factor and continuous covarites pool (adjusted covariates will only be the subset of these covariates)
FactorCovariates = c('Diffname_short','run','lane','index','Cell_Type_of_Origin', 'Cell_Line_of_Origin', 'Tissue_of_Origin', 'Reprogramming_Vector_Type','Reprogramming_Gene_Combination', 'Donor_Life_Stage','Originating_Lab','Gender','Donor_ID','Disease','Race','Ethnicity','Cell_Line_Type')
ContCovariates = NULL
```
Synapse id of count matrix used for the analysis is `r COUNT_ID` and the synapse id of meta data table used for the analysis is `r METADATA_ID`. Outliers were extracted from `r OUTLIERS_ID`

Factor covariates considered for analysis are `r FactorCovariates`, and continuous covariates considered for the analysis are `r ContCovariates`.

Obtain count matrix and metadata from synapse.
```{r getdata, cache=TRUE, include=FALSE}
# Get count matrix
COUNT_OBJ = synGet(COUNT_ID)
ALL_USED_IDs = COUNT_OBJ$properties$id
COUNT = fread(getFileLocation(COUNT_OBJ), data.table=FALSE)
row.names(COUNT) = COUNT[,1]

# Get metadata
METADATA_OBJ = synTableQuery(paste('SELECT * FROM',METADATA_ID,sep=' '))
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_OBJ@schema
METADATA = METADATA_OBJ@values
```

Preprocess counts matrix and metadata.
We separate MESO samples into early (5 day) and late (15 and 30 day).
```{r preprocessing, include=FALSE}
# Preprocess metadata
METADATA[METADATA == 'N/A'] = 'Not Applicable'

# Assign new values for MESO-5, 15 and 30 samples
METADATA$Diffname_short[METADATA$Diffname_short == 'MESO-5'] = 'MESO_EARLY'
METADATA$Diffname_short[METADATA$Diffname_short == 'MESO-15' | 
                          METADATA$Diffname_short == 'MESO-30'] = 'MESO_LATE'
rownames(METADATA) = METADATA$UID

```

### Preprocess data
* Remove somatic samples and samples with type NA.
* Remove samples that failed QC and samples classified as exclude.
* Remove samples with abnormal karyotypes.
* Select only EB state
```{r filtering, echo=TRUE}
#### Pre processing mRNA expression counts and metadata ####
metadata_filtered <- 
  METADATA %>%
  filter(Diffname_short == "EB") %>%
  filter(UID %in% colnames(COUNT)) %>%
  filter(Cell_Type == "PSC") %>%
  filter(!is.na(Cell_Type)) %>%
  filter(pass_qc) %>%
  filter(!exclude) %>%
  filter(C4_Karyotype_Result != "abnormal" | !is.na(C4_Karyotype_Result))

REMOVED_UID <- setdiff(METADATA$UID, metadata_filtered$UID)
METADATA <- METADATA[metadata_filtered$UID,]
COUNT <- COUNT[, METADATA$UID]
```

The following `r length(REMOVED_UID)` samples were removed:

`r REMOVED_UID` 

### CPM Normalisation
Determine design matrix for normalisation and differential expression analysis. 

Remove genes that have less than 1 cpm counts in at least 50% of each of the individual differentiation stages.
```{r cpmnormalisation}
tmp <- tapply(colnames(COUNT),
              factor(METADATA$Diffname_short),
              function(cols,COUNT){PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[,cols])},
              COUNT)

ugenes <- c()
for (i in unique(METADATA$Diffname_short)) {
  ugenes <- unique(c(ugenes,tmp[[i]]$filteredExprMatrix$genes[,1]))
}

COUNT <- COUNT[ugenes,,drop=F]
PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT,MIN_GENE_CPM=0,
                                                 MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
```

### Covariate clustering
Determine relationship between covariates. 

```{r covariates.clustering}
# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates)]

# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)

# Drop covariates with unilevel
dropCovariates <- names(which(sapply(lapply(COVARIATES,levels),length) == 1))
FactorCovariates <- setdiff(FactorCovariates,dropCovariates)
ContCovariates <- setdiff(ContCovariates,dropCovariates)
COVARIATES <- COVARIATES[,c(FactorCovariates,ContCovariates)]
```

```{r covariates.relation}
ggMosaicPlot(factor(COVARIATES$Donor_ID),factor(COVARIATES$Originating_Lab))

ggMosaicPlot(factor(COVARIATES$Cell_Type_of_Origin),factor(COVARIATES$Tissue_of_Origin))

ggMosaicPlot(factor(COVARIATES$Donor_Life_Stage),factor(COVARIATES$Tissue_of_Origin))

ggMosaicPlot(factor(COVARIATES$Reprogramming_Gene_Combination),factor(COVARIATES$Reprogramming_Vector_Type))

ggMosaicPlot(factor(COVARIATES$Donor_ID),factor(COVARIATES$Cell_Line_Type))

ggMosaicPlot(factor(COVARIATES$Reprogramming_Gene_Combination),factor(COVARIATES$Cell_Line_Type))

ggMosaicPlot(factor(COVARIATES$Reprogramming_Vector_Type),factor(COVARIATES$Cell_Line_Type))
```

Covariate correlation

```{r covariates.correlation, fig.width=12, fig.height=10}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 1)
ggheatmap.show(COVARIATES.CORRELATION$plot, col.width=0.3, row.width=0.15)
```

Initial normalisation usign voom (with NULL design)

```{r initial.voom.normalisation}
VOOM.GENE_EXPRESSION = voom(PROCESSED_COUNTS$filteredExprMatrix, design=NULL, plot=T)

# Find PC of gene expression and significant covariates that are highly correlated with PCs
DM = getDesignMatrix(COVARIATES, Intercept = F)
```

Clustering of initial normalised data (with NULL design)

```{r decompse.normalise.data, cache=TRUE, fig.height=20, fig.width=20}
# Find principal components of expression to plot
PC <- prcomp(scale(VOOM.GENE_EXPRESSION$E))

# Determine number of clusters automatically using pamk
pam.cluster <- pamk(t(VOOM.GENE_EXPRESSION$E), krange=2:10)

# Plot first 2 PCs
plotdata <- data.frame(UID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2], 
                       cluster=pam.cluster$pamobject$clustering)

plotdata <- merge(plotdata, METADATA, by="UID")

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Cell_Type_of_Origin, shape=Cell_Line_Type, size=Gender))
p <- p + theme_bw() + scale_size_manual(values = c(4, 3)) + theme(legend.position="top") 
p
```

### Normalisation
Correlation between pca of unadjusted mRNA expression and covariates is used to find significant covariates

```{r preAdjusted.covariates}
preAdjustedSigCovars = runPCAandPlotCorrelations(VOOM.GENE_EXPRESSION$E, COVARIATES,'NULL design(voom-normalized)', isKeyPlot=TRUE)

# Find significant covariates
adjustCovars = preAdjustedSigCovars$significantCovars
```

Significant covariates to adjust at FDR 0.1 are `r adjustCovars`

```{r preAdjustedSigCovars.NULL, fig.width=20, fig.height=10}
preAdjustedSigCovars[["PC_res"]][[1]]$plotData
```

```{r preAdjustedSigCovars.NULL.ALL, fig.width=20, fig.height=10}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

Since many covariates are confounded, re-normalising COVARIATES with a iterative design matrix.

```{r iterative.adjusted.voom.normalisation}
postAdjustCovars = names(which.max(preAdjustedSigCovars$Effects.significantCovars))
residualSigCovars = preAdjustedSigCovars
while(length(residualSigCovars$significantCovars)!=0){
  print(paste('Using following covariates in the model',paste(postAdjustCovars,collapse=','),sep=':'))
  
  # Post adjusted design matrix
  DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F],Intercept = F)
  
  VOOM.ADJUSTED.GENE_EXPRESSION = voom(PROCESSED_COUNTS$filteredExprMatrix, 
                                       design=DM1$design, plot=F)
  
  # Residuals after normalisation
  RESIDUAL.GENE_EXPRESSION = calcResiduals(VOOM.ADJUSTED.GENE_EXPRESSION$E, 
                                           DM1$design,sampleWeights=VOOM.ADJUSTED.GENE_EXPRESSION$weights)
  
  # Residual covariates to choose from
  residCovars <- setdiff(c(FactorCovariates,ContCovariates),
                         postAdjustCovars)
  
  # Find PC of residual gene expression and significant covariates that are highly correlated with PCs
  residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                                COVARIATES[,residCovars],
                                                'all adjusted design(voom-normalized)',
                                                isKeyPlot=TRUE)
  
  # Add postadjusted covariates (if any)
  postAdjustCovars = unique(c(postAdjustCovars,
                              names(which.max(residualSigCovars$Effects.significantCovars))))
}
```

Significant covariates to adjust at FDR 0.1 after considering confounding effects are `r postAdjustCovars`

```{r adjusted.voom.normalisation}
# Post adjusted design matrix
DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F], Intercept = F)

VOOM.ADJUSTED.GENE_EXPRESSION = voom(PROCESSED_COUNTS$filteredExprMatrix,
                                     design=DM1$design, plot=T)  
```

### Sanity Check
Residualise significant covariates using a linear model and find correlation between PCA of residuals with covariates

```{r calculate.residuals, include=FALSE}
# Residuals after normalisation
RESIDUAL.GENE_EXPRESSION = calcResiduals(VOOM.ADJUSTED.GENE_EXPRESSION$E, DM1$design, 
                                         sampleWeights = VOOM.ADJUSTED.GENE_EXPRESSION$weights)

# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                              COVARIATES,
                                              'residual matrix of all adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
```

```{r residualSigCovars, fig.width=20, fig.height=10}
residualSigCovars[["PC_res"]][[1]]$plotData
```

```{r residualSigCovars.ALL, fig.width=20, fig.height=10}
residualSigCovars[["PC_res"]][[2]]$plotData
```

Readjust for covariates, normalise and perform outlier analysis (as a sanity check)

```{r new.design, cache=TRUE, fig.height=15, fig.width=15}
# Find principal components of expression to plot
PC <- prcomp(scale(VOOM.ADJUSTED.GENE_EXPRESSION$E))

# Determine number of clusters automatically using pamk
pam.cluster <- pamk(t(VOOM.ADJUSTED.GENE_EXPRESSION$E), krange=2:10)

# Plot first 2 PCs
plotdata <- data.frame(UID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2], 
                       cluster=pam.cluster$pamobject$clustering)

plotdata <- merge(plotdata, METADATA, by="UID")

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Cell_Type_of_Origin, shape=Cell_Line_Type, size=Gender))
p <- p + theme_bw() + scale_size_manual(values = c(4, 3)) + theme(legend.position="top") 
p
```

#### Custom design for differential expression
* Design only with Cell Line Type and technical covariates (run, lane, index), and
* Design with Cell Line Type, Donor ID and technical covariates (run, lane, index)
```{r custom.design, echo=FALSE}
DIFF.EXP <- list()
GNames <- rownames(VOOM.ADJUSTED.GENE_EXPRESSION$E)
for (design in c('withoutDonorID','withDonorID')){
  if(design == 'withoutDonorID'){
    DESIGN <- getDesignMatrix(COVARIATES[,c('Cell_Line_Type','run','lane','index')], Intercept = F)
  } else {
    DESIGN <- getDesignMatrix(COVARIATES[,c('Cell_Line_Type','Donor_ID','run','lane','index')], Intercept = F)
  }
  colnames(DESIGN$design) = gsub("[[:punct:]]", "_",colnames(DESIGN$design))
  
  print(paste('Getting differentially expressed genes using limma package with following co-efficients',paste(colnames(DESIGN$design),collapse=','),'in linear model',sep=' '))
  
  print('Degenerate columns in the new design are:')
  print(linColumnFinder(DESIGN$design))
  
  # Fitting linear model
  FIT <- lmFit(VOOM.ADJUSTED.GENE_EXPRESSION$E, design = DESIGN$design, weights = VOOM.ADJUSTED.GENE_EXPRESSION$weights)
  
  # Make contrast to check differential expression between different differentiation stages
  CONT.NAMES <- colnames(DESIGN$design)[grep('Cell_Line_Type',colnames(DESIGN$design))]
  CONT.NAMES <- combn(CONT.NAMES,2)
  CONT.NAMES <- apply(CONT.NAMES,2,paste,collapse='-')
  
  CONT <- makeContrasts(contrasts=CONT.NAMES,levels=colnames(FIT$coefficients))
  
  # Refit contrasts
  FIT.CONTRAST <- contrasts.fit(FIT,CONT)
  
  # Estimate moderated t-statistics
  FIT.CONTRAST <- eBayes(FIT.CONTRAST)
  
  # Obtain all the differential expession combinations
  DIFF.EXP[[design]]$logFC <- data.frame(row.names = GNames)
  DIFF.EXP[[design]]$adj.P.Val <- data.frame(row.names = GNames)
  
  for (i in CONT.NAMES){
    tmp <- topTable(FIT.CONTRAST, coef=i, number=length(GNames))
    DIFF.EXP[[design]]$logFC[,str_replace_all(i,"Cell_Line_Type","")] <- tmp[GNames,'logFC']
    DIFF.EXP[[design]]$adj.P.Val[,str_replace_all(i,"Cell_Line_Type","")] <- tmp[GNames,'adj.P.Val']
  }
  
  # Get number of significantly differentialy expressed genes with adj.P.Val <= 0.05 and abs(logFC) >= 2
  DIFF.EXP[[design]]$SIG.EXP <- DIFF.EXP[[design]]$adj.P.Val<=0.05 & abs(DIFF.EXP[[design]]$logFC) >= 2
  DIFF.EXP[[design]]$NUM.SIG.EXP <- colSums(DIFF.EXP[[design]]$SIG.EXP)
}
```
No genes significantly expressed between iPSc and hESc

Store covariates, design matrix, and voom adjusted gene expression

```{r synapsestore, echo=FALSE, include=FALSE,eval=FALSE}
if (SYNAPSE_STORE){  
  ActivityName <- 'Differential Expression Analysis of eXpress aligned data EB only'
  
  # Code
  CODE <- File('./DiffExpAnal_Express_EB.Rmd',name = 'Differential Expression Analysis Express EB',parentId = parentId)
  CODE <- synStore(CODE, used = ALL_USED_IDs, activityName = ActivityName, executed = '')
  
  # Expression Data
  EXP <- as.data.frame(VOOM.ADJUSTED.GENE_EXPRESSION$E)
  EXP$Genes <- row.names(EXP)
  EXP <- EXP[,c(dim(EXP)[2],1:(dim(EXP)[2]-1))]
  
  FC <- merge(rownameToFirstColumn(DIFF.EXP$withoutDonorID$logFC,'GeneNames'),
              rownameToFirstColumn(DIFF.EXP$withDonorID$logFC,'GeneNames'),
              by='GeneNames')
  colnames(FC) <- c("GeneNames","ESC-iPSC.withoutDonor" "ESC-iPSC.withDonor")
  
  write.table(FC,file='./CellLineType_FoldChange_Express_EB.tsv',sep='\t',row.names=F,quote=F)
  FC <- File('./CellLineType_FoldChange_Express_EB.tsv',name = 'Differential Expression Analysis Express logFC EB',parentId = parentId)
  FC <- synStore(FC, used = ALL_USED_IDs, activityName = activityName, executed=CODE$properties$id)
  
  PVAL <- merge(rownameToFirstColumn(DIFF.EXP$withoutDonorID$adj.P.Val,'GeneNames'),
                rownameToFirstColumn(DIFF.EXP$withDonorID$adj.P.Val,'GeneNames'),
                by='GeneNames')
  colnames(PVAL) <- c("GeneNames","ESC-iPSC.withoutDonor","ESC-iPSC.withDonor")
  
  write.table(PVAL,file='./CellLineType_Pvalue_Express_EB.tsv',sep='\t',row.names=F,quote=F)
  PVAL <- File('./CellLineType_Pvalue_Express_EB.tsv',name = 'Differential Expression Analysis Express pvalue EB',parentId = parentId)
  PVAL <- synStore(PVAL, used = ALL_USED_IDs, activityName = activityName, executed=CODE$properties$id)
}
```